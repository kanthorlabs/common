// Code generated by mockery v2.41.0. DO NOT EDIT.

package jetstream

import (
	context "context"

	jetstream "github.com/nats-io/nats.go/jetstream"
	mock "github.com/stretchr/testify/mock"

	nats "github.com/nats-io/nats.go"
)

// JetStream is an autogenerated mock type for the JetStream type
type JetStream struct {
	mock.Mock
}

type JetStream_Expecter struct {
	mock *mock.Mock
}

func (_m *JetStream) EXPECT() *JetStream_Expecter {
	return &JetStream_Expecter{mock: &_m.Mock}
}

// AccountInfo provides a mock function with given fields: ctx
func (_m *JetStream) AccountInfo(ctx context.Context) (*jetstream.AccountInfo, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AccountInfo")
	}

	var r0 *jetstream.AccountInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*jetstream.AccountInfo, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *jetstream.AccountInfo); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.AccountInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_AccountInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AccountInfo'
type JetStream_AccountInfo_Call struct {
	*mock.Call
}

// AccountInfo is a helper method to define mock.On call
//   - ctx context.Context
func (_e *JetStream_Expecter) AccountInfo(ctx interface{}) *JetStream_AccountInfo_Call {
	return &JetStream_AccountInfo_Call{Call: _e.mock.On("AccountInfo", ctx)}
}

func (_c *JetStream_AccountInfo_Call) Run(run func(ctx context.Context)) *JetStream_AccountInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *JetStream_AccountInfo_Call) Return(_a0 *jetstream.AccountInfo, _a1 error) *JetStream_AccountInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_AccountInfo_Call) RunAndReturn(run func(context.Context) (*jetstream.AccountInfo, error)) *JetStream_AccountInfo_Call {
	_c.Call.Return(run)
	return _c
}

// Consumer provides a mock function with given fields: ctx, stream, consumer
func (_m *JetStream) Consumer(ctx context.Context, stream string, consumer string) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for Consumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, consumer)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, stream, consumer)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_Consumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Consumer'
type JetStream_Consumer_Call struct {
	*mock.Call
}

// Consumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *JetStream_Expecter) Consumer(ctx interface{}, stream interface{}, consumer interface{}) *JetStream_Consumer_Call {
	return &JetStream_Consumer_Call{Call: _e.mock.On("Consumer", ctx, stream, consumer)}
}

func (_c *JetStream_Consumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *JetStream_Consumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *JetStream_Consumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *JetStream_Consumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_Consumer_Call) RunAndReturn(run func(context.Context, string, string) (jetstream.Consumer, error)) *JetStream_Consumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *JetStream) CreateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConsumer'
type JetStream_CreateConsumer_Call struct {
	*mock.Call
}

// CreateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *JetStream_Expecter) CreateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *JetStream_CreateConsumer_Call {
	return &JetStream_CreateConsumer_Call{Call: _e.mock.On("CreateConsumer", ctx, stream, cfg)}
}

func (_c *JetStream_CreateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *JetStream_CreateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *JetStream_CreateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *JetStream_CreateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *JetStream_CreateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateKeyValue'
type JetStream_CreateKeyValue_Call struct {
	*mock.Call
}

// CreateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *JetStream_Expecter) CreateKeyValue(ctx interface{}, cfg interface{}) *JetStream_CreateKeyValue_Call {
	return &JetStream_CreateKeyValue_Call{Call: _e.mock.On("CreateKeyValue", ctx, cfg)}
}

func (_c *JetStream_CreateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *JetStream_CreateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *JetStream_CreateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *JetStream_CreateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *JetStream_CreateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateObjectStore'
type JetStream_CreateObjectStore_Call struct {
	*mock.Call
}

// CreateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *JetStream_Expecter) CreateObjectStore(ctx interface{}, cfg interface{}) *JetStream_CreateObjectStore_Call {
	return &JetStream_CreateObjectStore_Call{Call: _e.mock.On("CreateObjectStore", ctx, cfg)}
}

func (_c *JetStream_CreateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *JetStream_CreateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *JetStream_CreateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *JetStream_CreateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *JetStream_CreateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *JetStream) CreateOrUpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateOrUpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateConsumer'
type JetStream_CreateOrUpdateConsumer_Call struct {
	*mock.Call
}

// CreateOrUpdateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *JetStream_Expecter) CreateOrUpdateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *JetStream_CreateOrUpdateConsumer_Call {
	return &JetStream_CreateOrUpdateConsumer_Call{Call: _e.mock.On("CreateOrUpdateConsumer", ctx, stream, cfg)}
}

func (_c *JetStream_CreateOrUpdateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *JetStream_CreateOrUpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *JetStream_CreateOrUpdateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *JetStream_CreateOrUpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateOrUpdateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *JetStream_CreateOrUpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateOrUpdateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateOrUpdateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateKeyValue'
type JetStream_CreateOrUpdateKeyValue_Call struct {
	*mock.Call
}

// CreateOrUpdateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *JetStream_Expecter) CreateOrUpdateKeyValue(ctx interface{}, cfg interface{}) *JetStream_CreateOrUpdateKeyValue_Call {
	return &JetStream_CreateOrUpdateKeyValue_Call{Call: _e.mock.On("CreateOrUpdateKeyValue", ctx, cfg)}
}

func (_c *JetStream_CreateOrUpdateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *JetStream_CreateOrUpdateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *JetStream_CreateOrUpdateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *JetStream_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateOrUpdateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *JetStream_CreateOrUpdateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateOrUpdateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateOrUpdateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateObjectStore'
type JetStream_CreateOrUpdateObjectStore_Call struct {
	*mock.Call
}

// CreateOrUpdateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *JetStream_Expecter) CreateOrUpdateObjectStore(ctx interface{}, cfg interface{}) *JetStream_CreateOrUpdateObjectStore_Call {
	return &JetStream_CreateOrUpdateObjectStore_Call{Call: _e.mock.On("CreateOrUpdateObjectStore", ctx, cfg)}
}

func (_c *JetStream_CreateOrUpdateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *JetStream_CreateOrUpdateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *JetStream_CreateOrUpdateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *JetStream_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateOrUpdateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *JetStream_CreateOrUpdateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrUpdateStream provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateOrUpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrUpdateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateOrUpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrUpdateStream'
type JetStream_CreateOrUpdateStream_Call struct {
	*mock.Call
}

// CreateOrUpdateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *JetStream_Expecter) CreateOrUpdateStream(ctx interface{}, cfg interface{}) *JetStream_CreateOrUpdateStream_Call {
	return &JetStream_CreateOrUpdateStream_Call{Call: _e.mock.On("CreateOrUpdateStream", ctx, cfg)}
}

func (_c *JetStream_CreateOrUpdateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *JetStream_CreateOrUpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *JetStream_CreateOrUpdateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *JetStream_CreateOrUpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateOrUpdateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *JetStream_CreateOrUpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// CreateStream provides a mock function with given fields: ctx, cfg
func (_m *JetStream) CreateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for CreateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_CreateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateStream'
type JetStream_CreateStream_Call struct {
	*mock.Call
}

// CreateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *JetStream_Expecter) CreateStream(ctx interface{}, cfg interface{}) *JetStream_CreateStream_Call {
	return &JetStream_CreateStream_Call{Call: _e.mock.On("CreateStream", ctx, cfg)}
}

func (_c *JetStream_CreateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *JetStream_CreateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *JetStream_CreateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *JetStream_CreateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_CreateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *JetStream_CreateStream_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConsumer provides a mock function with given fields: ctx, stream, consumer
func (_m *JetStream) DeleteConsumer(ctx context.Context, stream string, consumer string) error {
	ret := _m.Called(ctx, stream, consumer)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConsumer")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, stream, consumer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStream_DeleteConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConsumer'
type JetStream_DeleteConsumer_Call struct {
	*mock.Call
}

// DeleteConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - consumer string
func (_e *JetStream_Expecter) DeleteConsumer(ctx interface{}, stream interface{}, consumer interface{}) *JetStream_DeleteConsumer_Call {
	return &JetStream_DeleteConsumer_Call{Call: _e.mock.On("DeleteConsumer", ctx, stream, consumer)}
}

func (_c *JetStream_DeleteConsumer_Call) Run(run func(ctx context.Context, stream string, consumer string)) *JetStream_DeleteConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *JetStream_DeleteConsumer_Call) Return(_a0 error) *JetStream_DeleteConsumer_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_DeleteConsumer_Call) RunAndReturn(run func(context.Context, string, string) error) *JetStream_DeleteConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteKeyValue provides a mock function with given fields: ctx, bucket
func (_m *JetStream) DeleteKeyValue(ctx context.Context, bucket string) error {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for DeleteKeyValue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStream_DeleteKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteKeyValue'
type JetStream_DeleteKeyValue_Call struct {
	*mock.Call
}

// DeleteKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *JetStream_Expecter) DeleteKeyValue(ctx interface{}, bucket interface{}) *JetStream_DeleteKeyValue_Call {
	return &JetStream_DeleteKeyValue_Call{Call: _e.mock.On("DeleteKeyValue", ctx, bucket)}
}

func (_c *JetStream_DeleteKeyValue_Call) Run(run func(ctx context.Context, bucket string)) *JetStream_DeleteKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_DeleteKeyValue_Call) Return(_a0 error) *JetStream_DeleteKeyValue_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_DeleteKeyValue_Call) RunAndReturn(run func(context.Context, string) error) *JetStream_DeleteKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteObjectStore provides a mock function with given fields: ctx, bucket
func (_m *JetStream) DeleteObjectStore(ctx context.Context, bucket string) error {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for DeleteObjectStore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, bucket)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStream_DeleteObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteObjectStore'
type JetStream_DeleteObjectStore_Call struct {
	*mock.Call
}

// DeleteObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *JetStream_Expecter) DeleteObjectStore(ctx interface{}, bucket interface{}) *JetStream_DeleteObjectStore_Call {
	return &JetStream_DeleteObjectStore_Call{Call: _e.mock.On("DeleteObjectStore", ctx, bucket)}
}

func (_c *JetStream_DeleteObjectStore_Call) Run(run func(ctx context.Context, bucket string)) *JetStream_DeleteObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_DeleteObjectStore_Call) Return(_a0 error) *JetStream_DeleteObjectStore_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_DeleteObjectStore_Call) RunAndReturn(run func(context.Context, string) error) *JetStream_DeleteObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteStream provides a mock function with given fields: ctx, stream
func (_m *JetStream) DeleteStream(ctx context.Context, stream string) error {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStream")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, stream)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JetStream_DeleteStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteStream'
type JetStream_DeleteStream_Call struct {
	*mock.Call
}

// DeleteStream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *JetStream_Expecter) DeleteStream(ctx interface{}, stream interface{}) *JetStream_DeleteStream_Call {
	return &JetStream_DeleteStream_Call{Call: _e.mock.On("DeleteStream", ctx, stream)}
}

func (_c *JetStream_DeleteStream_Call) Run(run func(ctx context.Context, stream string)) *JetStream_DeleteStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_DeleteStream_Call) Return(_a0 error) *JetStream_DeleteStream_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_DeleteStream_Call) RunAndReturn(run func(context.Context, string) error) *JetStream_DeleteStream_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValue provides a mock function with given fields: ctx, bucket
func (_m *JetStream) KeyValue(ctx context.Context, bucket string) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for KeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.KeyValue, error)); ok {
		return rf(ctx, bucket)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.KeyValue); ok {
		r0 = rf(ctx, bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_KeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValue'
type JetStream_KeyValue_Call struct {
	*mock.Call
}

// KeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *JetStream_Expecter) KeyValue(ctx interface{}, bucket interface{}) *JetStream_KeyValue_Call {
	return &JetStream_KeyValue_Call{Call: _e.mock.On("KeyValue", ctx, bucket)}
}

func (_c *JetStream_KeyValue_Call) Run(run func(ctx context.Context, bucket string)) *JetStream_KeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_KeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *JetStream_KeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_KeyValue_Call) RunAndReturn(run func(context.Context, string) (jetstream.KeyValue, error)) *JetStream_KeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStoreNames provides a mock function with given fields: ctx
func (_m *JetStream) KeyValueStoreNames(ctx context.Context) jetstream.KeyValueNamesLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for KeyValueStoreNames")
	}

	var r0 jetstream.KeyValueNamesLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.KeyValueNamesLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValueNamesLister)
		}
	}

	return r0
}

// JetStream_KeyValueStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStoreNames'
type JetStream_KeyValueStoreNames_Call struct {
	*mock.Call
}

// KeyValueStoreNames is a helper method to define mock.On call
//   - ctx context.Context
func (_e *JetStream_Expecter) KeyValueStoreNames(ctx interface{}) *JetStream_KeyValueStoreNames_Call {
	return &JetStream_KeyValueStoreNames_Call{Call: _e.mock.On("KeyValueStoreNames", ctx)}
}

func (_c *JetStream_KeyValueStoreNames_Call) Run(run func(ctx context.Context)) *JetStream_KeyValueStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *JetStream_KeyValueStoreNames_Call) Return(_a0 jetstream.KeyValueNamesLister) *JetStream_KeyValueStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_KeyValueStoreNames_Call) RunAndReturn(run func(context.Context) jetstream.KeyValueNamesLister) *JetStream_KeyValueStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// KeyValueStores provides a mock function with given fields: ctx
func (_m *JetStream) KeyValueStores(ctx context.Context) jetstream.KeyValueLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for KeyValueStores")
	}

	var r0 jetstream.KeyValueLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.KeyValueLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValueLister)
		}
	}

	return r0
}

// JetStream_KeyValueStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'KeyValueStores'
type JetStream_KeyValueStores_Call struct {
	*mock.Call
}

// KeyValueStores is a helper method to define mock.On call
//   - ctx context.Context
func (_e *JetStream_Expecter) KeyValueStores(ctx interface{}) *JetStream_KeyValueStores_Call {
	return &JetStream_KeyValueStores_Call{Call: _e.mock.On("KeyValueStores", ctx)}
}

func (_c *JetStream_KeyValueStores_Call) Run(run func(ctx context.Context)) *JetStream_KeyValueStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *JetStream_KeyValueStores_Call) Return(_a0 jetstream.KeyValueLister) *JetStream_KeyValueStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_KeyValueStores_Call) RunAndReturn(run func(context.Context) jetstream.KeyValueLister) *JetStream_KeyValueStores_Call {
	_c.Call.Return(run)
	return _c
}

// ListStreams provides a mock function with given fields: _a0, _a1
func (_m *JetStream) ListStreams(_a0 context.Context, _a1 ...jetstream.StreamListOpt) jetstream.StreamInfoLister {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListStreams")
	}

	var r0 jetstream.StreamInfoLister
	if rf, ok := ret.Get(0).(func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamInfoLister); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.StreamInfoLister)
		}
	}

	return r0
}

// JetStream_ListStreams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListStreams'
type JetStream_ListStreams_Call struct {
	*mock.Call
}

// ListStreams is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 ...jetstream.StreamListOpt
func (_e *JetStream_Expecter) ListStreams(_a0 interface{}, _a1 ...interface{}) *JetStream_ListStreams_Call {
	return &JetStream_ListStreams_Call{Call: _e.mock.On("ListStreams",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *JetStream_ListStreams_Call) Run(run func(_a0 context.Context, _a1 ...jetstream.StreamListOpt)) *JetStream_ListStreams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.StreamListOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.StreamListOpt)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_ListStreams_Call) Return(_a0 jetstream.StreamInfoLister) *JetStream_ListStreams_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_ListStreams_Call) RunAndReturn(run func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamInfoLister) *JetStream_ListStreams_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStore provides a mock function with given fields: ctx, bucket
func (_m *JetStream) ObjectStore(ctx context.Context, bucket string) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, bucket)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, bucket)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.ObjectStore); ok {
		r0 = rf(ctx, bucket)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, bucket)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_ObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStore'
type JetStream_ObjectStore_Call struct {
	*mock.Call
}

// ObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - bucket string
func (_e *JetStream_Expecter) ObjectStore(ctx interface{}, bucket interface{}) *JetStream_ObjectStore_Call {
	return &JetStream_ObjectStore_Call{Call: _e.mock.On("ObjectStore", ctx, bucket)}
}

func (_c *JetStream_ObjectStore_Call) Run(run func(ctx context.Context, bucket string)) *JetStream_ObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_ObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *JetStream_ObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_ObjectStore_Call) RunAndReturn(run func(context.Context, string) (jetstream.ObjectStore, error)) *JetStream_ObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStoreNames provides a mock function with given fields: ctx
func (_m *JetStream) ObjectStoreNames(ctx context.Context) jetstream.ObjectStoreNamesLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStoreNames")
	}

	var r0 jetstream.ObjectStoreNamesLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.ObjectStoreNamesLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStoreNamesLister)
		}
	}

	return r0
}

// JetStream_ObjectStoreNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStoreNames'
type JetStream_ObjectStoreNames_Call struct {
	*mock.Call
}

// ObjectStoreNames is a helper method to define mock.On call
//   - ctx context.Context
func (_e *JetStream_Expecter) ObjectStoreNames(ctx interface{}) *JetStream_ObjectStoreNames_Call {
	return &JetStream_ObjectStoreNames_Call{Call: _e.mock.On("ObjectStoreNames", ctx)}
}

func (_c *JetStream_ObjectStoreNames_Call) Run(run func(ctx context.Context)) *JetStream_ObjectStoreNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *JetStream_ObjectStoreNames_Call) Return(_a0 jetstream.ObjectStoreNamesLister) *JetStream_ObjectStoreNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_ObjectStoreNames_Call) RunAndReturn(run func(context.Context) jetstream.ObjectStoreNamesLister) *JetStream_ObjectStoreNames_Call {
	_c.Call.Return(run)
	return _c
}

// ObjectStores provides a mock function with given fields: ctx
func (_m *JetStream) ObjectStores(ctx context.Context) jetstream.ObjectStoresLister {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ObjectStores")
	}

	var r0 jetstream.ObjectStoresLister
	if rf, ok := ret.Get(0).(func(context.Context) jetstream.ObjectStoresLister); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStoresLister)
		}
	}

	return r0
}

// JetStream_ObjectStores_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ObjectStores'
type JetStream_ObjectStores_Call struct {
	*mock.Call
}

// ObjectStores is a helper method to define mock.On call
//   - ctx context.Context
func (_e *JetStream_Expecter) ObjectStores(ctx interface{}) *JetStream_ObjectStores_Call {
	return &JetStream_ObjectStores_Call{Call: _e.mock.On("ObjectStores", ctx)}
}

func (_c *JetStream_ObjectStores_Call) Run(run func(ctx context.Context)) *JetStream_ObjectStores_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *JetStream_ObjectStores_Call) Return(_a0 jetstream.ObjectStoresLister) *JetStream_ObjectStores_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_ObjectStores_Call) RunAndReturn(run func(context.Context) jetstream.ObjectStoresLister) *JetStream_ObjectStores_Call {
	_c.Call.Return(run)
	return _c
}

// OrderedConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *JetStream) OrderedConsumer(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for OrderedConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.OrderedConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.OrderedConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_OrderedConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OrderedConsumer'
type JetStream_OrderedConsumer_Call struct {
	*mock.Call
}

// OrderedConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.OrderedConsumerConfig
func (_e *JetStream_Expecter) OrderedConsumer(ctx interface{}, stream interface{}, cfg interface{}) *JetStream_OrderedConsumer_Call {
	return &JetStream_OrderedConsumer_Call{Call: _e.mock.On("OrderedConsumer", ctx, stream, cfg)}
}

func (_c *JetStream_OrderedConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.OrderedConsumerConfig)) *JetStream_OrderedConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.OrderedConsumerConfig))
	})
	return _c
}

func (_c *JetStream_OrderedConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *JetStream_OrderedConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_OrderedConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.OrderedConsumerConfig) (jetstream.Consumer, error)) *JetStream_OrderedConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// Publish provides a mock function with given fields: ctx, subject, payload, opts
func (_m *JetStream) Publish(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Publish")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []byte, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_Publish_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Publish'
type JetStream_Publish_Call struct {
	*mock.Call
}

// Publish is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *JetStream_Expecter) Publish(ctx interface{}, subject interface{}, payload interface{}, opts ...interface{}) *JetStream_Publish_Call {
	return &JetStream_Publish_Call{Call: _e.mock.On("Publish",
		append([]interface{}{ctx, subject, payload}, opts...)...)}
}

func (_c *JetStream_Publish_Call) Run(run func(ctx context.Context, subject string, payload []byte, opts ...jetstream.PublishOpt)) *JetStream_Publish_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_Publish_Call) Return(_a0 *jetstream.PubAck, _a1 error) *JetStream_Publish_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_Publish_Call) RunAndReturn(run func(context.Context, string, []byte, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *JetStream_Publish_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsync provides a mock function with given fields: subject, payload, opts
func (_m *JetStream) PublishAsync(subject string, payload []byte, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, subject, payload)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(subject, payload, opts...)
	}
	if rf, ok := ret.Get(0).(func(string, []byte, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(subject, payload, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(string, []byte, ...jetstream.PublishOpt) error); ok {
		r1 = rf(subject, payload, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_PublishAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsync'
type JetStream_PublishAsync_Call struct {
	*mock.Call
}

// PublishAsync is a helper method to define mock.On call
//   - subject string
//   - payload []byte
//   - opts ...jetstream.PublishOpt
func (_e *JetStream_Expecter) PublishAsync(subject interface{}, payload interface{}, opts ...interface{}) *JetStream_PublishAsync_Call {
	return &JetStream_PublishAsync_Call{Call: _e.mock.On("PublishAsync",
		append([]interface{}{subject, payload}, opts...)...)}
}

func (_c *JetStream_PublishAsync_Call) Run(run func(subject string, payload []byte, opts ...jetstream.PublishOpt)) *JetStream_PublishAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(string), args[1].([]byte), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_PublishAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *JetStream_PublishAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_PublishAsync_Call) RunAndReturn(run func(string, []byte, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *JetStream_PublishAsync_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncComplete provides a mock function with given fields:
func (_m *JetStream) PublishAsyncComplete() <-chan struct{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncComplete")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// JetStream_PublishAsyncComplete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncComplete'
type JetStream_PublishAsyncComplete_Call struct {
	*mock.Call
}

// PublishAsyncComplete is a helper method to define mock.On call
func (_e *JetStream_Expecter) PublishAsyncComplete() *JetStream_PublishAsyncComplete_Call {
	return &JetStream_PublishAsyncComplete_Call{Call: _e.mock.On("PublishAsyncComplete")}
}

func (_c *JetStream_PublishAsyncComplete_Call) Run(run func()) *JetStream_PublishAsyncComplete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStream_PublishAsyncComplete_Call) Return(_a0 <-chan struct{}) *JetStream_PublishAsyncComplete_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_PublishAsyncComplete_Call) RunAndReturn(run func() <-chan struct{}) *JetStream_PublishAsyncComplete_Call {
	_c.Call.Return(run)
	return _c
}

// PublishAsyncPending provides a mock function with given fields:
func (_m *JetStream) PublishAsyncPending() int {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for PublishAsyncPending")
	}

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// JetStream_PublishAsyncPending_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishAsyncPending'
type JetStream_PublishAsyncPending_Call struct {
	*mock.Call
}

// PublishAsyncPending is a helper method to define mock.On call
func (_e *JetStream_Expecter) PublishAsyncPending() *JetStream_PublishAsyncPending_Call {
	return &JetStream_PublishAsyncPending_Call{Call: _e.mock.On("PublishAsyncPending")}
}

func (_c *JetStream_PublishAsyncPending_Call) Run(run func()) *JetStream_PublishAsyncPending_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *JetStream_PublishAsyncPending_Call) Return(_a0 int) *JetStream_PublishAsyncPending_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_PublishAsyncPending_Call) RunAndReturn(run func() int) *JetStream_PublishAsyncPending_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsg provides a mock function with given fields: ctx, msg, opts
func (_m *JetStream) PublishMsg(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt) (*jetstream.PubAck, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsg")
	}

	var r0 *jetstream.PubAck
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)); ok {
		return rf(ctx, msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) *jetstream.PubAck); ok {
		r0 = rf(ctx, msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*jetstream.PubAck)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(ctx, msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_PublishMsg_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsg'
type JetStream_PublishMsg_Call struct {
	*mock.Call
}

// PublishMsg is a helper method to define mock.On call
//   - ctx context.Context
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *JetStream_Expecter) PublishMsg(ctx interface{}, msg interface{}, opts ...interface{}) *JetStream_PublishMsg_Call {
	return &JetStream_PublishMsg_Call{Call: _e.mock.On("PublishMsg",
		append([]interface{}{ctx, msg}, opts...)...)}
}

func (_c *JetStream_PublishMsg_Call) Run(run func(ctx context.Context, msg *nats.Msg, opts ...jetstream.PublishOpt)) *JetStream_PublishMsg_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(context.Context), args[1].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_PublishMsg_Call) Return(_a0 *jetstream.PubAck, _a1 error) *JetStream_PublishMsg_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_PublishMsg_Call) RunAndReturn(run func(context.Context, *nats.Msg, ...jetstream.PublishOpt) (*jetstream.PubAck, error)) *JetStream_PublishMsg_Call {
	_c.Call.Return(run)
	return _c
}

// PublishMsgAsync provides a mock function with given fields: msg, opts
func (_m *JetStream) PublishMsgAsync(msg *nats.Msg, opts ...jetstream.PublishOpt) (jetstream.PubAckFuture, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, msg)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PublishMsgAsync")
	}

	var r0 jetstream.PubAckFuture
	var r1 error
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)); ok {
		return rf(msg, opts...)
	}
	if rf, ok := ret.Get(0).(func(*nats.Msg, ...jetstream.PublishOpt) jetstream.PubAckFuture); ok {
		r0 = rf(msg, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.PubAckFuture)
		}
	}

	if rf, ok := ret.Get(1).(func(*nats.Msg, ...jetstream.PublishOpt) error); ok {
		r1 = rf(msg, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_PublishMsgAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishMsgAsync'
type JetStream_PublishMsgAsync_Call struct {
	*mock.Call
}

// PublishMsgAsync is a helper method to define mock.On call
//   - msg *nats.Msg
//   - opts ...jetstream.PublishOpt
func (_e *JetStream_Expecter) PublishMsgAsync(msg interface{}, opts ...interface{}) *JetStream_PublishMsgAsync_Call {
	return &JetStream_PublishMsgAsync_Call{Call: _e.mock.On("PublishMsgAsync",
		append([]interface{}{msg}, opts...)...)}
}

func (_c *JetStream_PublishMsgAsync_Call) Run(run func(msg *nats.Msg, opts ...jetstream.PublishOpt)) *JetStream_PublishMsgAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.PublishOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.PublishOpt)
			}
		}
		run(args[0].(*nats.Msg), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_PublishMsgAsync_Call) Return(_a0 jetstream.PubAckFuture, _a1 error) *JetStream_PublishMsgAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_PublishMsgAsync_Call) RunAndReturn(run func(*nats.Msg, ...jetstream.PublishOpt) (jetstream.PubAckFuture, error)) *JetStream_PublishMsgAsync_Call {
	_c.Call.Return(run)
	return _c
}

// Stream provides a mock function with given fields: ctx, stream
func (_m *JetStream) Stream(ctx context.Context, stream string) (jetstream.Stream, error) {
	ret := _m.Called(ctx, stream)

	if len(ret) == 0 {
		panic("no return value specified for Stream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (jetstream.Stream, error)); ok {
		return rf(ctx, stream)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) jetstream.Stream); ok {
		r0 = rf(ctx, stream)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, stream)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_Stream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stream'
type JetStream_Stream_Call struct {
	*mock.Call
}

// Stream is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
func (_e *JetStream_Expecter) Stream(ctx interface{}, stream interface{}) *JetStream_Stream_Call {
	return &JetStream_Stream_Call{Call: _e.mock.On("Stream", ctx, stream)}
}

func (_c *JetStream_Stream_Call) Run(run func(ctx context.Context, stream string)) *JetStream_Stream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_Stream_Call) Return(_a0 jetstream.Stream, _a1 error) *JetStream_Stream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_Stream_Call) RunAndReturn(run func(context.Context, string) (jetstream.Stream, error)) *JetStream_Stream_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNameBySubject provides a mock function with given fields: ctx, subject
func (_m *JetStream) StreamNameBySubject(ctx context.Context, subject string) (string, error) {
	ret := _m.Called(ctx, subject)

	if len(ret) == 0 {
		panic("no return value specified for StreamNameBySubject")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (string, error)); ok {
		return rf(ctx, subject)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) string); ok {
		r0 = rf(ctx, subject)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, subject)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_StreamNameBySubject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNameBySubject'
type JetStream_StreamNameBySubject_Call struct {
	*mock.Call
}

// StreamNameBySubject is a helper method to define mock.On call
//   - ctx context.Context
//   - subject string
func (_e *JetStream_Expecter) StreamNameBySubject(ctx interface{}, subject interface{}) *JetStream_StreamNameBySubject_Call {
	return &JetStream_StreamNameBySubject_Call{Call: _e.mock.On("StreamNameBySubject", ctx, subject)}
}

func (_c *JetStream_StreamNameBySubject_Call) Run(run func(ctx context.Context, subject string)) *JetStream_StreamNameBySubject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *JetStream_StreamNameBySubject_Call) Return(_a0 string, _a1 error) *JetStream_StreamNameBySubject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_StreamNameBySubject_Call) RunAndReturn(run func(context.Context, string) (string, error)) *JetStream_StreamNameBySubject_Call {
	_c.Call.Return(run)
	return _c
}

// StreamNames provides a mock function with given fields: _a0, _a1
func (_m *JetStream) StreamNames(_a0 context.Context, _a1 ...jetstream.StreamListOpt) jetstream.StreamNameLister {
	_va := make([]interface{}, len(_a1))
	for _i := range _a1 {
		_va[_i] = _a1[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StreamNames")
	}

	var r0 jetstream.StreamNameLister
	if rf, ok := ret.Get(0).(func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamNameLister); ok {
		r0 = rf(_a0, _a1...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.StreamNameLister)
		}
	}

	return r0
}

// JetStream_StreamNames_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StreamNames'
type JetStream_StreamNames_Call struct {
	*mock.Call
}

// StreamNames is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 ...jetstream.StreamListOpt
func (_e *JetStream_Expecter) StreamNames(_a0 interface{}, _a1 ...interface{}) *JetStream_StreamNames_Call {
	return &JetStream_StreamNames_Call{Call: _e.mock.On("StreamNames",
		append([]interface{}{_a0}, _a1...)...)}
}

func (_c *JetStream_StreamNames_Call) Run(run func(_a0 context.Context, _a1 ...jetstream.StreamListOpt)) *JetStream_StreamNames_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]jetstream.StreamListOpt, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(jetstream.StreamListOpt)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *JetStream_StreamNames_Call) Return(_a0 jetstream.StreamNameLister) *JetStream_StreamNames_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *JetStream_StreamNames_Call) RunAndReturn(run func(context.Context, ...jetstream.StreamListOpt) jetstream.StreamNameLister) *JetStream_StreamNames_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConsumer provides a mock function with given fields: ctx, stream, cfg
func (_m *JetStream) UpdateConsumer(ctx context.Context, stream string, cfg jetstream.ConsumerConfig) (jetstream.Consumer, error) {
	ret := _m.Called(ctx, stream, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConsumer")
	}

	var r0 jetstream.Consumer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)); ok {
		return rf(ctx, stream, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, jetstream.ConsumerConfig) jetstream.Consumer); ok {
		r0 = rf(ctx, stream, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Consumer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, jetstream.ConsumerConfig) error); ok {
		r1 = rf(ctx, stream, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_UpdateConsumer_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConsumer'
type JetStream_UpdateConsumer_Call struct {
	*mock.Call
}

// UpdateConsumer is a helper method to define mock.On call
//   - ctx context.Context
//   - stream string
//   - cfg jetstream.ConsumerConfig
func (_e *JetStream_Expecter) UpdateConsumer(ctx interface{}, stream interface{}, cfg interface{}) *JetStream_UpdateConsumer_Call {
	return &JetStream_UpdateConsumer_Call{Call: _e.mock.On("UpdateConsumer", ctx, stream, cfg)}
}

func (_c *JetStream_UpdateConsumer_Call) Run(run func(ctx context.Context, stream string, cfg jetstream.ConsumerConfig)) *JetStream_UpdateConsumer_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(jetstream.ConsumerConfig))
	})
	return _c
}

func (_c *JetStream_UpdateConsumer_Call) Return(_a0 jetstream.Consumer, _a1 error) *JetStream_UpdateConsumer_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_UpdateConsumer_Call) RunAndReturn(run func(context.Context, string, jetstream.ConsumerConfig) (jetstream.Consumer, error)) *JetStream_UpdateConsumer_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateKeyValue provides a mock function with given fields: ctx, cfg
func (_m *JetStream) UpdateKeyValue(ctx context.Context, cfg jetstream.KeyValueConfig) (jetstream.KeyValue, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateKeyValue")
	}

	var r0 jetstream.KeyValue
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.KeyValueConfig) jetstream.KeyValue); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.KeyValue)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.KeyValueConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_UpdateKeyValue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateKeyValue'
type JetStream_UpdateKeyValue_Call struct {
	*mock.Call
}

// UpdateKeyValue is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.KeyValueConfig
func (_e *JetStream_Expecter) UpdateKeyValue(ctx interface{}, cfg interface{}) *JetStream_UpdateKeyValue_Call {
	return &JetStream_UpdateKeyValue_Call{Call: _e.mock.On("UpdateKeyValue", ctx, cfg)}
}

func (_c *JetStream_UpdateKeyValue_Call) Run(run func(ctx context.Context, cfg jetstream.KeyValueConfig)) *JetStream_UpdateKeyValue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.KeyValueConfig))
	})
	return _c
}

func (_c *JetStream_UpdateKeyValue_Call) Return(_a0 jetstream.KeyValue, _a1 error) *JetStream_UpdateKeyValue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_UpdateKeyValue_Call) RunAndReturn(run func(context.Context, jetstream.KeyValueConfig) (jetstream.KeyValue, error)) *JetStream_UpdateKeyValue_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateObjectStore provides a mock function with given fields: ctx, cfg
func (_m *JetStream) UpdateObjectStore(ctx context.Context, cfg jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateObjectStore")
	}

	var r0 jetstream.ObjectStore
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.ObjectStoreConfig) jetstream.ObjectStore); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.ObjectStore)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.ObjectStoreConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_UpdateObjectStore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateObjectStore'
type JetStream_UpdateObjectStore_Call struct {
	*mock.Call
}

// UpdateObjectStore is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.ObjectStoreConfig
func (_e *JetStream_Expecter) UpdateObjectStore(ctx interface{}, cfg interface{}) *JetStream_UpdateObjectStore_Call {
	return &JetStream_UpdateObjectStore_Call{Call: _e.mock.On("UpdateObjectStore", ctx, cfg)}
}

func (_c *JetStream_UpdateObjectStore_Call) Run(run func(ctx context.Context, cfg jetstream.ObjectStoreConfig)) *JetStream_UpdateObjectStore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.ObjectStoreConfig))
	})
	return _c
}

func (_c *JetStream_UpdateObjectStore_Call) Return(_a0 jetstream.ObjectStore, _a1 error) *JetStream_UpdateObjectStore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_UpdateObjectStore_Call) RunAndReturn(run func(context.Context, jetstream.ObjectStoreConfig) (jetstream.ObjectStore, error)) *JetStream_UpdateObjectStore_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateStream provides a mock function with given fields: ctx, cfg
func (_m *JetStream) UpdateStream(ctx context.Context, cfg jetstream.StreamConfig) (jetstream.Stream, error) {
	ret := _m.Called(ctx, cfg)

	if len(ret) == 0 {
		panic("no return value specified for UpdateStream")
	}

	var r0 jetstream.Stream
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)); ok {
		return rf(ctx, cfg)
	}
	if rf, ok := ret.Get(0).(func(context.Context, jetstream.StreamConfig) jetstream.Stream); ok {
		r0 = rf(ctx, cfg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(jetstream.Stream)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, jetstream.StreamConfig) error); ok {
		r1 = rf(ctx, cfg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JetStream_UpdateStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateStream'
type JetStream_UpdateStream_Call struct {
	*mock.Call
}

// UpdateStream is a helper method to define mock.On call
//   - ctx context.Context
//   - cfg jetstream.StreamConfig
func (_e *JetStream_Expecter) UpdateStream(ctx interface{}, cfg interface{}) *JetStream_UpdateStream_Call {
	return &JetStream_UpdateStream_Call{Call: _e.mock.On("UpdateStream", ctx, cfg)}
}

func (_c *JetStream_UpdateStream_Call) Run(run func(ctx context.Context, cfg jetstream.StreamConfig)) *JetStream_UpdateStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(jetstream.StreamConfig))
	})
	return _c
}

func (_c *JetStream_UpdateStream_Call) Return(_a0 jetstream.Stream, _a1 error) *JetStream_UpdateStream_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *JetStream_UpdateStream_Call) RunAndReturn(run func(context.Context, jetstream.StreamConfig) (jetstream.Stream, error)) *JetStream_UpdateStream_Call {
	_c.Call.Return(run)
	return _c
}

// NewJetStream creates a new instance of JetStream. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewJetStream(t interface {
	mock.TestingT
	Cleanup(func())
}) *JetStream {
	mock := &JetStream{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
